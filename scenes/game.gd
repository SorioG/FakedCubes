extends Node2D
class_name Game

@onready var players_node = $players
@onready var bottominfo = $hud/lobby_ui/BottomInfo
@onready var multi_spawner: MultiplayerSpawner = $PlayerSpawner
@onready var bot_mp_spawner: MultiplayerSpawner = $BotSpawner

@onready var chat_window = $hud/ChatWindow

@onready var pause_bg = $hud/PauseBG
@onready var pause_win = $hud/PauseWindow

var lan_announcer: PacketPeerUDP

var current_map: Node2D

var current_gamemode = {"name": "Unknown", "base": BaseGamemode}:
	set(val):
		current_gamemode = val
		
		if is_instance_valid(gamemode_node):
			gamemode_node.free()
		
		gamemode_node = val["base"].new()
		gamemode_node.game = self

var gamemode_node: BaseGamemode

signal player_spawned(player: Player)

var players: Array[Player] = []

var local_player: Player

enum STATE {
	LOBBY = 1,
	INGAME = 2
}

@export var game_state = STATE.LOBBY
@export var net_mode: int = Global.net_mode

@export var num_bots: int = 0

@export var spawn_local_player = true

@export var autoplay = false

@export var bot_change_skin = true

var max_impostors: int = 3

var bot_players: Array[Player] = []

var winning_role: int

var gamemode_idx: int

var name_generator: NameGenerator = NameGenerator.new()
var rng: RandomNumberGenerator = RandomNumberGenerator.new()

var is_split_screen: bool = false
var split_screen_player: int = 1
var local_player2: Player

## Server information to be sent to server list and clients connecting
var server_info: Dictionary = {
	"name": "Server", # Name of the server
	"port": Global.server_port, # Server Port
	"version": Global.version, # Version used by the server, disconnects clients that don't have it
	"dedicated": false, # Whatever or not this server is a dedicated server
	"gamemode": "Classic", # Name of the gamemode
	"players": 0, # Number of players connected (excluding bots)
	"bots": 0, # Number of the bots used
	"uuid": "", # UUID Generated by the server for invites and other identity purposes
	"allow_discord_invites": true, # Whatever or not to allow discord invites
	"discord_show_name": true, # Show or hide the server name for rich presence only
	"discord_public": false, # Allows joining the game without asking for invite
}

## List of player UUIDs that were banned by the server (with a reason)
var ban_list: Array[Dictionary] = []

var dediserver_confirmed = false

# Custom Maps
var is_using_custom_map = false
var custom_map_path: String = ""

var current_map_path: String = ""

var custom_lobby_path: String = ""

@export var can_change_map = true

@export var is_voice_chat_allowed = true
@export var is_custom_skins_allowed = true

var has_connected := true

var is_server_public := false

var masterserver_success := false

var lobby_client: WebSocketPeer

var webrtc_peers := {}

var webrtc_lobby_id := ""

var webrtc_mp_peer: WebRTCMultiplayerPeer

signal local_player_used_action(action: int)
signal game_ended


func spawn_player(is_local: bool, plr_name: String = "Player", is_new: bool = true, is_bot: bool = false) -> Player:
	var plr = Global.PLAYER_NODE.instantiate()
	plr.is_local_player = is_local
	plr.player_name = plr_name
	plr.name = plr_name
	plr.is_bot = is_bot
	
	emit_signal("player_spawned", plr)
	
	players_node.add_child(plr)
	
	if is_new:
		plr.animation.play("appear")
	
	if is_bot:
		plr.can_have_authority = false
	
	if is_local and is_split_screen:
		plr.action_prefix = "p{0}_".format([split_screen_player])
	
	# Handle Early Player Spawns (count them as innocent)
	if game_state == STATE.INGAME:
		#if current_gamemode["base"] == "impostor":
		#	plr.current_role = Global.PLAYER_ROLE.INNOCENT
		gamemode_node.player_join_early(plr)
	
	plr.position = get_random_spawn().position
	
	return plr

func _ready():
	rng.randomize()
	
	$hud/role_reveal.visible = false
	$hud/role_reveal/hide_timer.connect("timeout", _impostor_timer_end)
	
	multi_spawner.spawn_function = net_spawn_player
	bot_mp_spawner.spawn_function = net_bot_spawn
	
	multiplayer.peer_connected.connect(_on_peer_joined)
	multiplayer.peer_disconnected.connect(_on_peer_left)
	multiplayer.server_disconnected.connect(_on_disconnect)
	multiplayer.connected_to_server.connect(_on_connected)
	multiplayer.connection_failed.connect(_on_connection_failed)
	
	current_gamemode = Global.game_modes[0]
	gamemode_idx = 0
	
	$hud/vc_enable.connect("pressed", _enable_microphone)
	$hud/chat.connect("pressed", _show_chat_window)
	
	$hud/vc_enable.visible = is_voice_chat_allowed
	
	$ms_requests/ListRequest.connect("request_completed", _on_masterserver_response)
	$ms_requests/UpdateRequest.connect("request_completed", _on_masterserver_response)
	
	# Generate a server UUID for public server list and discord invites.
	server_info["uuid"] = Global.uuid.v4()
	
	if net_mode == Global.GAME_TYPE.SINGLEPLAYER:
		change_to_lobby()
		
		if spawn_local_player:
			#local_player = spawn_player(true, "Player1")
			multi_spawner.spawn(1)
		
		$bot_spawn_timer.connect("timeout", bot_spawn)
		$bot_spawn_timer.start()
		
		# Voice Chat is not needed in singleplayer
		$hud/vc_enable.visible = false
		is_voice_chat_allowed = false
	
	elif net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
		var err = OK
		var peer: MultiplayerPeer
		if Global.net_type == Global.NET_TYPE.DIRECT:
			peer = ENetMultiplayerPeer.new()
			err = peer.create_server(Global.server_port, Global.MAX_PLAYERS)
		elif Global.net_type == Global.NET_TYPE.WEBRTC:
			peer = WebRTCMultiplayerPeer.new()
			webrtc_mp_peer = peer
			webrtc_lobby_id = "invalid"
			err = peer.create_server()
		else:
			err = ERR_INVALID_PARAMETER
		
		is_server_public = Global.cubenet_is_public
		
		if err != OK:
			Global.alert("Failed to start the server, is the port open?", "Server Error")
			
			if Global.is_dedicated_server:
				# Automatically stop the dedicated server in case of the error
				get_tree().quit(1)
			
			_leave_game()
			return
		
		multiplayer.multiplayer_peer = peer
		
		change_to_lobby()
		
		server_info["dedicated"] = Global.is_dedicated_server
		
		if Global.net_type == Global.NET_TYPE.WEBRTC:
			lobby_client = WebSocketPeer.new()
			lobby_client.connect_to_url(Global.cubenet_get_websocket() + "/lobby")
		
		#net_spawn_player.rpc(multiplayer.get_unique_id())
		
		# Spawn a local player unless we are hosting a dedicated server
		if not Global.is_dedicated_server:
			multi_spawner.spawn(1)
			
			server_info["name"] = Global.client_info["username"] + "'s server"
		
		$bot_spawn_timer.connect("timeout", bot_spawn)
		$bot_spawn_timer.start()
		
		# Announce the server to LAN
		lan_announcer = PacketPeerUDP.new()
		lan_announcer.set_broadcast_enabled(true)
		# Should we keep the destination address with that one?
		lan_announcer.set_dest_address("255.255.255.255", 9887)
		
		$announce_timer.connect("timeout", _lan_announce)
		$announce_timer.start()
		
		handle_arguments()
		
		Global.start_server_thread()
		
		_update_server_info()
		
		if is_server_public:
			_list_public()
	
	elif net_mode == Global.GAME_TYPE.MULTIPLAYER_CLIENT:
		var peer: MultiplayerPeer
		has_connected = false
		$hud/lobby_ui/StartButton.visible = false
		
		
		#LoadingScreen.music.play()
		LoadingScreen.show_screen()
		LoadingScreen.loadlabel.text = tr("Connecting to the server...")
		
		if Global.net_type == Global.NET_TYPE.DIRECT:
			print("Connecting to " + Global.server_ip + ":" + str(Global.server_port))
			
			peer = ENetMultiplayerPeer.new()
			peer.create_client(Global.server_ip, Global.server_port)
			
			multiplayer.multiplayer_peer = peer
		elif Global.net_type == Global.NET_TYPE.WEBRTC:
			peer = WebRTCMultiplayerPeer.new()
			
			lobby_client = WebSocketPeer.new()
			lobby_client.connect_to_url(Global.cubenet_get_websocket() + "/lobby")
			
		else:
			Global.alert("Invalid Network Type", "Connection Failed")
			
			_leave_game()
		
		
	
	$hud/lobby_ui/StartButton.connect("pressed", _on_start_pressed)
	
	chat_window.visible = false
	
	#chat_window.add_message("User", "Test Message")
	chat_window.connect("type_message", _typed_message)
	chat_window.connect("new_message", _new_message)
	
	$dediserver_timer.connect("timeout", dediserver_autostart)
	
	if Global.is_dedicated_server:
		parse_server_config()
		
		$dediserver_timer.start()
	
	pause_bg.visible = false
	pause_win.visible = false
	
	$hud/menu.connect("pressed", _pause_pressed)
	$hud/PauseWindow/btns/resume.connect("pressed", _resume_pressed)
	$hud/PauseWindow/btns/quit.connect("pressed", _leave_game)

func _pause_pressed():
	pause_bg.visible = true
	pause_bg.modulate = Color.TRANSPARENT
	pause_win.visible = true
	#pause_win.position = Vector2(376, 80)
	
	pause_win.get_node("paused").play()
	
	var tween = create_tween()
	#tween.tween_property(pause_win, "position", Vector2(376, 55), 0.2)
	tween.tween_property(pause_bg, "modulate", Color.WHITE, 0.2)
	
	pause_win.get_node("btns/resume").grab_focus()
	
	if Global.net_mode == Global.GAME_TYPE.SINGLEPLAYER:
		get_tree().paused = true

func _resume_pressed():
	pause_bg.visible = false
	pause_win.visible = false
	#pause_bg.color = Color.from_string("#00000093", Color.BLACK)
	
	
	pause_win.get_node("resumed").play()
	
	if Global.net_mode == Global.GAME_TYPE.SINGLEPLAYER:
		get_tree().paused = false

func _leave_game():
	get_tree().set_deferred("paused", false)
	
	Global.net_mode = Global.GAME_TYPE.SINGLEPLAYER
	
	multiplayer.multiplayer_peer = OfflineMultiplayerPeer.new()
	Global.change_scene_file("res://scenes/menu_screen.tscn")

func parse_server_config():
	var config: ConfigFile = Global.server_config
	
	if not config: return
	
	server_info["name"] = config.get_value("Server", "name", "Dedicated Server")
	server_info["discord_allow_invites"] = config.get_value("Discord", "allow_invites", true)
	server_info["discord_show_name"] = config.get_value("Discord", "show_server_name", true)
	is_custom_skins_allowed = config.get_value("Server", "allow_custom_skins", true)
	is_voice_chat_allowed = config.get_value("Server", "voice_chat", true)
	
	num_bots = config.get_value("Game", "max_bots", 0)
	
	var lobby_map = config.get_value("Game", "lobby_map", "default")
	var s_gamemode = config.get_value("Game", "gamemode", 0)
	
	if lobby_map != "default":
		custom_lobby_path = Global.maps_path.path_join(lobby_map + ".tscn")
		
		change_to_lobby()
	
	current_gamemode = Global.game_modes[s_gamemode]
	gamemode_idx = s_gamemode

func change_to_lobby():
	if custom_lobby_path.is_empty():
		_change_map("lobby")
	else:
		load_custom_map(custom_lobby_path)

## Automatically start the game on a dedicated server
func dediserver_autostart():
	if game_state == STATE.INGAME: return
	if can_start_game() == "OK":
		if not dediserver_confirmed:
			dediserver_confirmed = true
			#print("[Game] Automatically starting the game")
			net_server_message.rpc("The game will now start after a few seconds")
		else:
			dediserver_confirmed = false
			_on_start_pressed.call_deferred()
			$dediserver_timer.stop()
	else:
		if dediserver_confirmed:
			net_server_message.rpc("Stopped the timer because the gamemode cannot be started")
		dediserver_confirmed = false

func _typed_message(msg: String):
	net_user_message.rpc(msg)

func _new_message(_user: String, _msg: String):
	if not chat_window.visible:
		$hud/chat.modulate = Color.WHITE
		$chat_new.play()
	else:
		$chat_new_reading.play()

@rpc("any_peer", "call_local", "reliable")
func net_user_message(msg: String):
	var id = multiplayer.get_remote_sender_id()
	var player: Player = players_node.get_node_or_null("Player" + str(id))
	if player:
		if not Global.is_dedicated_server:
			var avatar = ImageTexture.create_from_image(player.get_still_image())
			
			chat_window.add_message(player.player_name, msg, avatar)
		
		print("[Chat] " + player.player_name + ": " + msg)
	else:
		push_warning("Someone typed a message, but player does not exist")

@rpc("authority", "call_local", "reliable")
func net_server_message(msg: String):
	chat_window.add_message("Server", msg, load("res://assets/sprites/computer.png"))
	print("[Chat] Server: " + msg)

func _on_peer_joined(id: int):
	print("[Server] Player " + str(id) + " has connected")
	if multiplayer.is_server():
		if not current_map_path.is_empty():
			var file = FileAccess.open(current_map_path, FileAccess.READ)
			
			var netdata = Marshalls.raw_to_base64(file.get_buffer(file.get_length()))
			
			net_download_map.rpc_id(id, netdata)
			
			file.close()
		else:
			change_map.rpc_id(id, current_map.name)
		
		net_change_gamemode.rpc_id(id, gamemode_idx)
		
		# TODO: Automatically download required mods used from the server before spawning
	
	# Send the correct skin to a player (whatever or not it's a custom skin)
	if local_player:
		if local_player.skin_name == "Custom":
			local_player.net_load_custom_skin.rpc_id(id, local_player.custom_skin_data)
		else:
			local_player.net_set_skin.rpc_id(id, local_player.skin_name)
		
		local_player.net_set_hat.rpc_id(id, local_player.hat_name)
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("client_connected", [id])

func _on_peer_left(id: int):
	var player = players_node.get_node_or_null("Player" + str(id))
	
	if player:
		print("[Game] " + player.player_name + " left the game")
		player.disappear()

		if Global.is_dedicated_server and ("--close-on-empty" in OS.get_cmdline_args()):
			if multiplayer.get_peers().size() < 1:
				print("Closing automatically due to the server being empty")
				get_tree().quit.call_deferred()
	else:
		print("[Server] Player " + str(id) + " disconnected")
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("client_disconnected", [id])

func bot_spawn():
	var size = bot_players.size()
	var bnam = name_generator.new_name()
	if size < num_bots:
		#if Global.net_mode == Global.GAME_TYPE.SINGLEPLAYER:
		#	var bot = spawn_player(false, bnam[1], true, true)
		
		#	bot_players.push_back(bot)
		#elif Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
		bot_mp_spawner.spawn(bnam[1])
	
	elif size > num_bots:
		var bot = bot_players.pop_back()
		
		bot.disappear()
		

func net_bot_spawn(nam: String):
	var player := Global.PLAYER_NODE.instantiate()
	
	player.name = "Bot" + nam.md5_text()
	player.player_name = nam
	player.is_bot = true
	player.is_local_player = false
	player.can_have_authority = false
	
	player.has_spawned = true
	
	emit_signal("player_spawned", player)
	
	if multiplayer.is_server():
		player.position = get_random_spawn().position
		
		if game_state == STATE.INGAME:
			gamemode_node.player_join_early(player)
	
	bot_players.push_back(player)
	
	return player

func get_local_ip():
	var addr = IP.get_local_addresses()
	
	for ip in addr:
		var addr2 = ip.split(":")[0]
		
		if addr2.begins_with("192.168."):
			return addr2
	
	return "127.0.0.1"

func _process(_delta):
	
	bottominfo.text = "Gamemode: " + current_gamemode["name"]
	bottominfo.text += " | "
	
	if Global.net_mode == Global.GAME_TYPE.SINGLEPLAYER:
		bottominfo.text += "Singleplayer"
	elif Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
		if Global.net_type == Global.NET_TYPE.DIRECT:
			bottominfo.text += get_local_ip() + ":" + str(Global.server_port)
		elif Global.net_type == Global.NET_TYPE.WEBRTC:
			if webrtc_lobby_id == "invalid":
				bottominfo.text += "<Waiting for signaling server>"
			else:
				bottominfo.text += "Lobby ID: " + webrtc_lobby_id
	elif Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_CLIENT:
		if Global.net_type == Global.NET_TYPE.DIRECT:
			bottominfo.text += Global.server_ip + ":" + str(Global.server_port)
		elif Global.net_type == Global.NET_TYPE.WEBRTC:
			bottominfo.text += "Lobby ID: " + webrtc_lobby_id
	
	if local_player:
		if not get_tree().paused:
			update_players()
		
		if Input.is_action_just_pressed("menu") and not pause_win.visible:
			_pause_pressed()
	
	if game_state == STATE.INGAME and not get_tree().paused:
		gamemode_node.game_tick()
		
		if multiplayer.is_server():
			winning_role = check_end_game()
			
			if winning_role != Global.PLAYER_ROLE.NONE:
				end_game()
				
				net_end_game.rpc(winning_role)
	
	if autoplay:
		if bot_players.size() >= num_bots and game_state == STATE.LOBBY:
			_on_start_pressed()
			autoplay = false
	
	$hud/vc_enable.visible = is_voice_chat_allowed
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("game_tick", [_delta])
	
	if lobby_client:
		var state = lobby_client.get_ready_state()
		lobby_client.poll()
		
		if state == WebSocketPeer.STATE_CONNECTING:
			pass
		elif state == WebSocketPeer.STATE_OPEN:
			while lobby_client.get_available_packet_count():
				var packet = lobby_client.get_packet()
				var json = JSON.parse_string(packet.get_string_from_utf8())
				
				_lobby_client_handle_packet(json)
		elif state == WebSocketPeer.STATE_CLOSING:
			pass
		elif state == WebSocketPeer.STATE_CLOSED:
			if Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
				Global.alert("You have been disconnected from the signaling server, you will no longer receive new connections", "WebRTC Error")
				
			else:
				if not has_connected:
					Global.alert("Failed to connect to signaling server (failed to join lobby)", "WebRTC Error")
					
					_leave_game()
			
			lobby_client = null

@rpc("authority", "call_local", "reliable")
func change_map(m: String):
	if not Global.maps[m]:
		return
	
	var old_name = m
	if is_instance_valid(current_map):
		old_name = current_map.name
		current_map.free()
	
	current_map_path = ""
	is_using_custom_map = false
	
	current_map = Global.maps[m].instantiate()
	
	current_map.name = m
	
	current_map.get_node("spawns").visible = false
	
	$map.add_child(current_map)
	
	move_players()
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("map_changed", [m, old_name])

func get_random_spawn():
	return current_map.get_node("spawns").get_children().pick_random()

func move_players():
	var plrs = players_node.get_children()
	
	for plr in plrs:
		if plr is Player:
			plr.position = get_random_spawn().position

func get_local_player() -> Player:
	if net_mode != Global.GAME_TYPE.SINGLEPLAYER:
		return players_node.get_node("Player"+str(multiplayer.get_unique_id()))
	
	return local_player

# This gets another local player on a split-screen mode, in which this is unused for this game.
func get_local_player2() -> Player:
	return local_player2


func net_spawn_player(id):
	var player := Global.PLAYER_NODE.instantiate()
	
	player.net_id = id # Unused?
	
	# Make sure that this player plays the spawn animation (does not play if the player was already here)
	player.has_spawned = true
	
	# Set their name to the peer's id to prevent errors.
	player.name = "Player" + str(id)
	# This player is not considered to be a local player (unless the client is controlling this player)
	player.is_local_player = false
	# Make this player sync the input data, as well as other ones like username.
	player.set_multiplayer_authority(id)
	
	# Just make sure to let the server sync their position and other states to prevent cheating.
	# This also fixes lag while the client predicts the movements.
	player.get_node("ServerSyncer").set_multiplayer_authority(1)
	
	# Then we will emit this signal to let them know that the player has spawned.
	emit_signal("player_spawned", player)
	
	if multiplayer.is_server():
		player.position = get_random_spawn().position
		
		if game_state == STATE.INGAME:
			gamemode_node.player_join_early(player)
	
	return player

@rpc("authority", "call_remote", "reliable")
func net_load_scripts(_scr: Array[String]):
	pass

func _change_map(map: String):
	#if Global.net_mode == Global.GAME_TYPE.SINGLEPLAYER:
	#	change_map(map)
	#if Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
	if multiplayer.is_server():
		change_map.rpc(map)

func can_start_game() -> String:
	return gamemode_node.can_start_game()

func _on_start_pressed():
	var err = can_start_game()
	
	if err != "OK":
		print("Failed to start game: " + err)
		
		if not Global.is_dedicated_server:
			var diag: AcceptDialog = $hud/FailDialog
			
			diag.dialog_text = "Failed to start game: " + err
			diag.popup()
		return
	
	$hud/lobby_ui.visible = false
	
	print("[Game] Successfully started the game")
	
	game_state = STATE.INGAME
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("game_started", [])
	
	#if Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST and multiplayer.is_server():
	#	multiplayer.multiplayer_peer.refuse_new_connections = true
	#	
	#	print("[Server] This server is now refusing connections.")
	
	if is_using_custom_map and can_change_map:
		load_custom_map(custom_map_path)
	
	gamemode_node.game_start()
	
	if gamemode_node.can_reveal_role:
		show_role_reveal()
	
	net_start_game.rpc()

@rpc("authority", "call_remote", "reliable")
func net_start_game():
	$hud/lobby_ui.visible = false
	
	gamemode_node.game_start()
	
	if gamemode_node.can_reveal_role:
		show_role_reveal()

func get_players(exclude_bots: bool = false) -> Array[Player]:
	var res: Array[Player] = []
	for plr in players_node.get_children():
		if plr is Player:
			if plr.is_bot and exclude_bots: continue
			if plr.c_game != self: continue
			res.append(plr)
	
	return res

func get_players_by_role(role: int) -> Array[Player]:
	var res: Array[Player] = []
	
	for plr in get_players():
		if plr.current_role == role:
			res.append(plr)
	
	return res

func show_role_reveal():
	
	# Make the reveal visible even without the player (to stop the bots from moving)
	$hud/role_reveal.visible = true
	
	if local_player:
		$hud/role_reveal/role_player.set_skin(local_player.get_skin()) # Try to match player's skin
		$hud/role_reveal/role_player.animation.play("idle2")
		
		if not multiplayer.is_server():
			$hud/role_reveal/role_text.text = "Waiting for server..."
			
			await local_player.get_node("ServerSyncer").synchronized
		
		gamemode_node.role_reveal($hud/role_reveal/role_text, $hud/role_reveal/role_player)
	
	$hud/role_reveal/hide_timer.start()

func end_game():
	change_to_lobby()
	
	print("[Game] The game has now ended. (Winning Role: " + str(winning_role) + ")")
	
	game_state = STATE.LOBBY
	$hud/lobby_ui.visible = true
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("game_ended", [winning_role])
	
	if Global.is_dedicated_server:
		$dediserver_timer.start()
	
	show_results()
	
	reset_players()
	
	if multiplayer.is_server():
		net_end_game.rpc(winning_role)
	#	multiplayer.multiplayer_peer.refuse_new_connections = false
		
	#	print("[Server] This server is now accepting connections.")
	
	emit_signal("game_ended")

func check_end_game() -> int:
	return gamemode_node.check_end_game()

func show_results():
	if not local_player: return
	$hud/role_reveal.visible = true
	$hud/role_reveal/hide_timer.start()
	$hud/role_reveal/role_player.animation.play("idle")
	
	gamemode_node.show_results($hud/role_reveal/role_text, $hud/role_reveal/role_player)
	
	$hud/role_reveal/role_player.set_skin(get_players_by_role(winning_role).pick_random().get_skin())
	

func get_alive_players() -> Array[Player]:
	var res: Array[Player] = []
	
	for plr in get_players():
		if plr.is_killed: continue
		
		res.append(plr)
	
	return res

func get_alive_players_by_role(role: int) -> Array[Player]:
	var res: Array[Player] = []
	
	for plr in get_players():
		if plr.is_killed: continue
		if plr.current_role != role: continue
		
		res.append(plr)
	
	return res

func get_dead_players() -> Array[Player]:
	var res: Array[Player] = []
	
	for plr in get_players():
		if not plr.is_killed: continue
		
		res.append(plr)
	
	return res

func reset_players():
	for plr in get_players():
		reset_player(plr)

func reset_player(plr: Player, reset_role: bool = true):
	plr.is_killed = false
	plr.camera.offset = Vector2()
	if reset_role:
		plr.current_role = Global.PLAYER_ROLE.NONE
	
	plr.animation.play("RESET")
	plr.is_idle = false
	plr.is_ghost = false
	plr.visible = true
	
	if multiplayer.is_server():
		plr.net_reset_player.rpc(reset_role)
	
	if Global.is_lua_enabled:
		ModLoader.call_hook("player_reset", [plr, reset_role])

func _impostor_timer_end():
	$hud/role_reveal.visible = false

func update_players():
	for player in get_players():
		if player == local_player: continue
		if game_state == STATE.INGAME:
			gamemode_node.update_player(player)
		else:
			player.get_node("impostor_icon").visible = false

@rpc("authority", "call_remote", "reliable")
func net_change_gamemode(id: int):
	current_gamemode = Global.game_modes[id]

func _enable_microphone():
	if Global.is_mobile and not Global.is_emulating_mobile:
		if not OS.request_permission("RECORD_AUDIO"): return
	
	if local_player.vc_input.playing:
		local_player.vc_input.stop()
	else:
		local_player.vc_input.play()

func _show_chat_window():
	$hud/chat.modulate = Color.from_string("#ffffff80", Color.WHITE)
	
	chat_window.visible = not chat_window.visible

func _lan_announce():
	_update_server_info()
	
	var json_str = JSON.stringify(server_info)
	var packet = "FC|" + Marshalls.utf8_to_base64(json_str)
	var _err = lan_announcer.put_packet(packet.to_utf8_buffer())
	
	#if err != OK:
	#	print("[Server] Failed to announce the server to LAN")
	#	$announce_timer.stop()
	
	if masterserver_success:
		_update_public()

func _update_server_info():
	server_info["gamemode"] = current_gamemode["name"]
	server_info["players"] = get_players(true).size()
	server_info["bots"] = bot_players.size()

@rpc("any_peer", "reliable", "call_local")
func custom_rpc(data: Dictionary):
	var id = multiplayer.get_remote_sender_id()
	
	gamemode_node.receive_custom_rpc(data, id)

func get_player_by_id(id: int) -> Player:
	return get_node_or_null("players/Player" + str(id))

func _on_disconnect():
	Global.alert("You have been disconnected from the server", "Disconnected")
	
	_leave_game()

func _on_connection_failed():
	Global.alert("Failed to connect to the server", "Connection Failed")
	
	_leave_game()

func _on_connected():
	LoadingScreen.loadlabel.text = "Sending client information..."
	
	net_client_info.rpc_id(1, Global.client_info)

func _exit_tree():
	if lobby_client is WebSocketPeer and lobby_client.get_ready_state() == WebSocketPeer.STATE_OPEN:
		lobby_client.close()

@rpc("call_remote", "reliable")
func net_end_game(winner: int):
	winning_role = winner
	end_game()

# This should be useful for handling arguments in a dedicated server (also works on listen server)
func handle_arguments():
	var i = 0
	var args = OS.get_cmdline_args()
	for line in args:
		if line == "--max-bots":
			num_bots = int(args[i+1])
			
			print("Adding " + str(num_bots) + " bots")
		
		if line == "--gamemode":
			var nam = int(args[i+1])
			
			if nam > Global.game_modes.size() or nam < 0:
				print("Invalid Gamemode, ignoring..")
			else:
				current_gamemode = Global.game_modes[nam]
				gamemode_idx = nam
				
				print("Changed gamemode to " + current_gamemode["name"])
		
		i += 1


func load_custom_map(path: String):
	var map = ResourceLoader.load(path, "PackedScene")
	
	if map is PackedScene:
		if is_instance_valid(current_map):
			current_map.free()
		
		var cmap = map.instantiate()
		
		current_map = cmap
		
		current_map_path = path
		
		$map.add_child(cmap)
		
		move_players()
		
		if multiplayer.is_server():
			var file = FileAccess.open(path, FileAccess.READ)
			
			var netdata = Marshalls.raw_to_base64(file.get_buffer(file.get_length()))
			
			net_download_map.rpc(netdata)
			
			file.close()
	else:
		print("[Game] Failed to load custom map (path: " + path + ")")

@rpc("call_remote", "reliable")
func net_download_map(file: String):
	var data = Marshalls.base64_to_raw(file)
	
	DirAccess.make_dir_absolute("user://net_downloads")
	
	var path = "user://net_downloads/" + file.md5_text() + ".tscn"
	
	var map = FileAccess.open(path, FileAccess.WRITE)
	
	map.store_buffer(data)
	
	map.close()
	
	load_custom_map.call_deferred(path)

@rpc("any_peer", "reliable", "call_local")
func net_client_info(info: Dictionary):
	assert(multiplayer.is_server(), "Server Only RPC Function")
	
	var id = multiplayer.get_remote_sender_id()
	
	if OS.is_debug_build():
		print("[Debug] Received Client Info from " + str(id) + ":")
		print(info)
	
	var can_join: bool = true
	var err_msg: String = "You are not allowed to join this server"
	
	var modded: bool = info["modded"]
	var mods: Array = info["mods"]
	var username: String = info["username"]
	var uuid: String = info["uuid"]
	var version: String = info["version"]
	var platform: String = info["platform"]
	
	# Remind the client that their version is outdated or newer than the server's version
	if version != Global.version:
		err_msg = "Outdated Version! This server is using " + Global.version
		can_join = false
	
	# Empty Usernames are kind of cheating.
	if username.is_empty() and can_join:
		err_msg = "The username must not be empty"
		can_join = false
	
	if uuid.is_empty() and can_join:
		err_msg = "Empty UUID - Possible ban evading or cheating"
		can_join = false
	
	# This client has a invalid uuid, don't trust it!
	if not Global.is_uuid_valid(uuid) and can_join:
		err_msg = "Invalid UUID - Did you modify your UUID?"
		can_join = false
		
		print("[WARN] Player " + str(id) + " has attempted to join with a invalid UUID!")
	
	if is_uuid_banned(uuid) and can_join:
		var reason = get_ban_reason(uuid)
		
		err_msg = "You have been banned from this server (reason: " + reason + ")"
		can_join = false
		
		print("[WARN] Player " + str(id) + " tried to join, but their UUID is banned")
	
	# If this server is modded, we can check whatever or not this client has some mods enabled.
	if ModLoader.required_mods.size() > 0 and can_join:
		var max_mods = ModLoader.required_mods.size()
		
		if not modded:
			err_msg = "You're connecting to a modded server, but you don't have any mods enabled. (" + str(max_mods) + " required mods used)"
			can_join = false
		else:
			var mod_count = 0
			for mod_id in mods:
				if ModLoader.required_mods.has(mod_id):
					mod_count += 1
			
			# This client does not have the server's required mods.
			if mod_count != max_mods:
				err_msg = "You do not have the " + str(max_mods-mod_count) + " required mods for this server."
				can_join = false
	
	# Let the mods handle it as well.
	if Global.is_lua_enabled:
		ModLoader.call_hook("handle_client_info", [info, err_msg, can_join])
	
	if can_join:
		print("[Game] " + username + " has joined the game (platform: " + platform + ", modded: " + str(modded) + ")")
		# Now that we have successfully checked the info, we will need to spawn this player.
		# Without doing it so, the player would get stuck on the loading screen.
		multi_spawner.spawn(id)
		net_server_info.rpc_id(id, server_info)
	else:
		if username:
			print("[Server] " + username + " failed to join the game")
		else:
			print("[Server] Player " + str(id) + " failed to join the game")
		
		if OS.is_debug_build():
			print_debug("[Debug] Player " + str(id) + " has failed the info check, message: ", err_msg)
		
		net_info_fail.rpc_id(id, err_msg)

@rpc("any_peer", "reliable", "call_local")
func net_info_fail(msg: String):
	assert(multiplayer.get_remote_sender_id() == 1, "Server Only, Not from another peer")
	
	Global.alert(msg, "Connection Failed")
	
	_leave_game()

@rpc("authority", "reliable", "call_local")
func net_server_info(info: Dictionary):
	has_connected = true
	server_info = info
	
	if OS.is_debug_build():
		print("[Debug] Received Server Info: ", info)

## Checks if the player's UUID was banned on the server
func is_uuid_banned(uuid: String) -> bool:
	for info in ban_list:
		var uid: String = info["uuid"]
		
		if uid == uuid:
			return true
	
	return false

## Gets the ban reason for this UUID
## If this uuid is not banned, it will return "not banned"
func get_ban_reason(uuid: String) -> String:
	for info in ban_list:
		var uid: String = info["uuid"]
		
		if uid == uuid:
			if info["reason"]:
				return info["reason"]
			else:
				return "no reason"
	
	return "not banned"

func _update_public():
	$ms_requests/UpdateRequest.request(
		Global.cubenet_server_url + "/servers/update", 
		Global.cubenet_headers + ["Content-Type: application/json"],
		HTTPClient.METHOD_POST,
		JSON.stringify(server_info)
	)

func _list_public():
	$ms_requests/ListRequest.request(
		Global.cubenet_server_url + "/servers/list", 
		Global.cubenet_headers + ["Content-Type: application/json"],
		HTTPClient.METHOD_POST,
		JSON.stringify(server_info)
	)

func _on_masterserver_response(_res: int, res_code: int, _headers: PackedStringArray, body: PackedByteArray):
	if res_code == 200 || res_code == 400:
		var json = JSON.parse_string(body.get_string_from_utf8())
		var success = json["success"]
		
		if success:
			if not masterserver_success:
				masterserver_success = true
				print("[CubeNet] Successfully registered this server to the list")
		else:
			if masterserver_success:
				masterserver_success = false
				print("[CubeNet] Failed to register/update the server to the list")
				print("[CubeNet] Error: ", json["error"])
				
				if not Global.is_dedicated_server:
					chat_window.add_message("CubeNet", "Failed to register/update this server to the list\n" + json["error"], load("res://assets/sprites/bigplayer.png"))
		
	else:
		masterserver_success = false
		
		print("[CubeNet] Failed to register/update this server (server error)")
		
		if not Global.is_dedicated_server:
			chat_window.add_message("CubeNet", "Failed to register/update this server to the list (server error)", load("res://assets/sprites/bigplayer.png"))

# Something that's useful for mods
func get_gamemode_name() -> String:
	return current_gamemode["name"]

func load_custom_map_by_name(n: String):
	if Global.custom_maps.has(n):
		load_custom_map(Global.custom_maps[n])
	else:
		print("[ERR] Custom map named '" + n + "' does not exist")

func send_server_message(msg: String):
	net_server_message.rpc(msg)

func send_server_message_to_id(id: int, msg: String):
	net_server_message.rpc_id(id, msg)

func send_player_message(msg: String):
	if Global.is_dedicated_server:
		print("[WARN] Tried to execute send_player_message on a dedicated server, please use send_server_message instead")
		net_server_message.rpc(msg)
	else:
		net_user_message.rpc(msg)
# End of useful functions for mods

func _handle_command(args: Array[String], cb: Callable):
	if args[0] == "list":
		var plist = str(get_players().size()) + " players online:\n"
		for plr in get_players():
			var pname = plr.player_name
			
			if not plr.is_bot:
				pname += " (id: " + str(plr.net_id) + ")"
			else:
				pname += " (bot)"
			
			if plr.is_killed:
				pname += " (dead)"
			
			if game_state == STATE.INGAME:
				pname += " (role: " + str(plr.current_role) + ")"
			
			plist += pname + "\n"
		
		cb.call(plist)
	
	if args[0] == "gamemode":
		if args.size() == 1:
			cb.call("Current Gamemode is " + current_gamemode["name"])
		else:
			var nam = int(args[1])
			
			if game_state == STATE.INGAME:
				cb.call("You can only change the gamemode while in the lobby")
				return
			
			if nam > Global.game_modes.size()-1 or nam < 0:
				cb.call("Invalid Gamemode, you can only set this to 0 to " + str(Global.game_modes.size()-1))
			else:
				current_gamemode = Global.game_modes[nam]
				gamemode_idx = nam
				
				cb.call("Changed Gamemode to " + current_gamemode["name"])
	
	if args[0] == "bots":
		if args.size() == 1:
			cb.call("Current Bot Count is " + str(num_bots))
		else:
			num_bots = int(args[1])
			
			cb.call("Changing the bot count to " + str(num_bots))
	
	if args[0] == "start":
		if game_state == STATE.INGAME:
			cb.call("You can only start the game while in the lobby")
			return
		
		_on_start_pressed()
	
	if args[0] == "help":
		var clist = "List of commands:\n"
		
		clist += "list - Get a list of players online\n"
		clist += "gamemode [index] - Change the gamemode, omit the index to get the current one\n"
		clist += "bots [count] - Change or get the bot count\n"
		clist += "start - Forcefully start the game\n"
		clist += "quit - Closes the server\n"
		
		cb.call(clist)

func _lobby_client_handle_packet(packet: Dictionary):
	var ptype: String = packet["packet"]
	var pdata: Dictionary = packet["data"]
	
	if not webrtc_mp_peer:
		webrtc_mp_peer = WebRTCMultiplayerPeer.new()
	
	var mp_peer: WebRTCMultiplayerPeer = webrtc_mp_peer
	
	if OS.is_debug_build():
		print("[Debug] [Lobby Client] Received packet type ", ptype)
	
	if ptype == "playerJoin":
		# Someone has joined the game (host only)
		var peerId = pdata["peerId"]
		var peer := WebRTCPeerConnection.new()
		webrtc_peers[str(peerId)] = peer
		
		peer.session_description_created.connect(_rtc_peer_desc_created.bind(peerId))
		peer.ice_candidate_created.connect(_rtc_peer_ice_candidate.bind(peerId))
		
		peer.initialize({
			"iceServers": Global.WEBRTC_ICE_SERVERS
		})
		
		mp_peer.add_peer(peer, peerId)
		
		print("[Lobby Client] Peer " + str(peerId) + " has connected to the lobby")
	
	if ptype == "lobby":
		if not pdata["isHost"]:
			mp_peer.create_client(pdata["peerId"])
			
			multiplayer.multiplayer_peer = mp_peer
			
			var hostId = pdata["hostId"]
			
			var hostPeer := WebRTCPeerConnection.new()
			webrtc_peers[str(hostId)] = hostPeer
			
			hostPeer.session_description_created.connect(_rtc_peer_desc_created.bind(hostId))
			hostPeer.ice_candidate_created.connect(_rtc_peer_ice_candidate.bind(hostId))
			
			hostPeer.initialize({
				"iceServers": Global.WEBRTC_ICE_SERVERS
			})
			
			mp_peer.add_peer(hostPeer, 1)
			
			print("[Lobby Client] Creating a offer for the host")
			
			hostPeer.create_offer()
			
		
		Global.server_ip = "webrtc:" + pdata["lobbyId"]
		server_info["webrtc_lobby_id"] = pdata["lobbyId"]
		webrtc_lobby_id = pdata["lobbyId"]
		
		print("[Lobby Client] Lobby ID: " + pdata["lobbyId"])
		
		if masterserver_success:
			_update_public()
	
	if ptype == "offer" or ptype == "answer":
		var peerId = pdata["fromId"]
		var peer: WebRTCPeerConnection = webrtc_peers[str(peerId)]
		
		if not peer:
			push_error("Cannot find peer with id ", peerId)
			return
		
		peer.set_remote_description(pdata["type"], pdata["sdp"])
		#mp_peer.add_peer(peer, peerId)
		
	
	if ptype == "candidate":
		var peerId = pdata["fromId"]
		var peer: WebRTCPeerConnection = webrtc_peers[str(peerId)]
		
		if not peer:
			push_error("Cannot find peer with id ", peerId)
			return
		
		peer.add_ice_candidate(pdata["media"], pdata["index"], pdata["name"])
	
	if ptype == "error":
		print("[Lobby Client] Error: " + pdata["msg"])
		
		if not Global.is_dedicated_server:
			chat_window.add_message("CubeNet", "Lobby Client Error: " + pdata["msg"], load("res://assets/sprites/bigplayer.png"))
	
	if ptype == "hello":
		_lobby_client_on_connect()

func _rtc_peer_desc_created(type: String, sdp: String, id: int):
	var pack = {
		"packet": type,
		"data": {
			"type": type,
			"sdp": sdp,
			"targetId": id
		}
	}
	
	var peer: WebRTCPeerConnection = webrtc_peers[str(id)]
	if not peer:
		push_error("Cannot find peer with id ", id)
		return
	
	peer.set_local_description(type, sdp)
	lobby_client.send_text(JSON.stringify(pack))

func _rtc_peer_ice_candidate(media: String, index: int, nam: String, id: int):
	var pack = {
		"packet": "candidate",
		"data": {
			"media": media,
			"index": index,
			"name": nam,
			"targetId": id
		}
	}
	
	var peer: WebRTCPeerConnection = webrtc_peers[str(id)]
	if not peer:
		push_error("Cannot find peer with id ", id)
		return
	
	lobby_client.send_text(JSON.stringify(pack))

func _lobby_client_on_connect():
	if Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_HOST:
		var pack = {
			"packet": "host",
			"data": {}
		}
		
		lobby_client.send_text(JSON.stringify(pack))
	elif Global.net_mode == Global.GAME_TYPE.MULTIPLAYER_CLIENT:
		var pack = {
			"packet": "join",
			"data": {
				"lobbyId": Global.server_ip
			}
		}
		
		lobby_client.send_text(JSON.stringify(pack))

## Whatever or not the player is allowed to control their character
## The false value means that the player will play the thinking animation for all players
func can_control_player() -> bool:
	if $hud/ChatWindow.visible: return false
	return true
